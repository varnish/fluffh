# FLUFFH - FUSE Layer for Universal File Functionality via HTTP

(This is a work in progress, it might not even compile at any given time)

Language: Go
Key dependencies: github.com/hanwen/go-fuse, github.com/colinmarc/cdb, github.com/tinylib/msgp

Goal: A FUSE layer that allows you to mount a specially prepared HTTP server/objectstore as a filesystem.

## Why CDB?

CVMFS uses SQLite databases to store the filesystem metadata. SQLite is great, but a lot more complex than CDB. CDB is
a simple key-value store that is very fast and very simple. It is also made to be read-only, which is perfect for our
use case.

## Why hanwen/go-fuse?

hanwen/go-fuse seems a bit more modern than bazil/fuse. While having a steeper learning curve, it grants a lot more
control over the filesystem.

## Why tinylib/msgp

msgp is a code generator for MessagePack. It is used to serialize the metadata of the files and directories. This is
done to avoid the overhead of JSON and to make the CDB files as small as possible.

## Design

FLUFFH uses CDB files to impose a filesystem structure upon HTTP. These files are generated by a object store
proxy that will enrich the objectstore with these CDB files. This avoids the rather
cumbersome data ingest pipeline of CVMFS.

## Caveats

* Filesystems is mounted read only.
* File are not assumed to change, but they can. S3 does support versioning and if the CDB files somehow can reference a
  version, we can support this.
* Directories can change.

## Caching strategy

The client (FLUFFH) will not do any meaningful caching. Every time a file is access or a directory is listed, the client
will make an HTTP request re-download the CDB file or the object.

The client will do read-ahead caching for files.

## Network caching strategy

The network caches, Varnish, should have some mechanism for invalidating the CDB indices.

There are two strategies:

1. Events are distributed to the caches, via the controller.
2. The caches have a helper process, which polls the storage proxy for changes. The helper can track at what point it
   got the last events and as such only get the relevant events.

If neither of these are suitable and there is a COLR (Cache of Last Resort), the mid-tier cache can operate with a
very short TTL on the CDB files as the COLR cache will sit next to the storage and should always receive invalidations.

## Use of Ranged HTTP requests

The client will use ranged HTTP requests to download files. When opening a file, it we could ask for the first chunk.
The chunk size should align with the Varnish Cache Slicer size.

## CDB Files

Each directory is represented by a CDB file. The keys are the filename, the values are the inode, encoded as JSON.

JSON structure:

```go 
package fluffh

type Metadata struct {
	Inode      uint64 `json:"inode"`
	Type       string `json:"type"`       // "file" or "dir"
	AccessBits uint32 `json:"accessBits"` // Permissions
	UID        uint32 `json:"uid"`
	GID        uint32 `json:"gid"`
	Size       int64  `json:"size"`
	Modified   int64  `json:"modified"`
	Created    int64  `json:"created"`
}

```